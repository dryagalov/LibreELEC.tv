diff -Naur u-boot-2a56c9f.orig/arch/arm/include/asm/saradc.h u-boot-2a56c9f/arch/arm/include/asm/saradc.h
--- u-boot-2a56c9f.orig/arch/arm/include/asm/saradc.h	2016-09-18 14:08:59.190190014 +0800
+++ u-boot-2a56c9f/arch/arm/include/asm/saradc.h	2016-09-18 14:11:04.094191048 +0800
@@ -37,5 +37,5 @@
 void saradc_enable(void);
 int saradc_disable(void);
 int  get_adc_sample_gxbb(int chan);
-
-#endif /*__AML_SARADC_H__*/
\ No newline at end of file
+int  get_adc_sample_gxbb_12bit(int chan);
+#endif /*__AML_SARADC_H__*/
diff -Naur u-boot-2a56c9f.orig/common/cmd_saradc.c u-boot-2a56c9f/common/cmd_saradc.c
--- u-boot-2a56c9f.orig/common/cmd_saradc.c	2016-09-18 14:08:59.090190013 +0800
+++ u-boot-2a56c9f/common/cmd_saradc.c	2016-09-18 14:12:31.326191770 +0800
@@ -47,6 +47,16 @@
 	return 0;
 }
 
+static int do_saradc_getval_12bit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char value_str[10];
+	int val = get_adc_sample_gxbb_12bit(current_channel);
+	printf("SARADC channel(%d) is 0x%x.\n", current_channel, val);
+	sprintf(value_str, "0x%x", val);
+	setenv(SARADC_VALUE, value_str);
+	return 0;
+}
+
 static int do_saradc_get_in_range(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	char value_str[10];
@@ -55,12 +65,34 @@
 	min = simple_strtoul(argv[1], NULL, 10);
 	max = simple_strtoul(argv[2], NULL, 10);
 	int donot_setenv = 0;
-	if (argc>3)
-    {
+	if (argc > 3) {
+		donot_setenv = simple_strtoul(argv[2], NULL, 10);
+	}
+	if ((val<min) || (val>max)) {
+		debug("SARADC channel(%d) is 0x%x, Out of range(0x%x~0x%x)!\n",
+			current_channel, val, min, max);
+		return -1;
+	}
+	debug("SARADC channel(%d) is 0x%x (0x%x~0x%x).\n",
+		current_channel, val, min, max);
+	sprintf(value_str, "0x%x", val);
+	if (!donot_setenv)
+		setenv(SARADC_VALUE, value_str);
+	return 0;
+}
+
+static int do_saradc_get_in_range_12bit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char value_str[10];
+	int max, min;
+	int val = get_adc_sample_gxbb_12bit(current_channel);
+	min = simple_strtoul(argv[1], NULL, 10);
+	max = simple_strtoul(argv[2], NULL, 10);
+	int donot_setenv = 0;
+	if (argc > 3) {
 		donot_setenv = simple_strtoul(argv[2], NULL, 10);
 	}
-	if ((val<min) || (val>max))
-	{
+	if ((val<min) || (val>max)) {
 		debug("SARADC channel(%d) is 0x%x, Out of range(0x%x~0x%x)!\n",
 			current_channel, val, min, max);
 		return -1;
@@ -105,4 +137,34 @@
 	"saradc get_in_range <min> <max>	- return 0 if current value in the range of current channel\n"
 );
 
+static cmd_tbl_t cmd_saradc_12bit_sub[] = {
+	U_BOOT_CMD_MKENT(open, 2, 0, do_saradc_open, "", ""),
+	U_BOOT_CMD_MKENT(close, 1, 0, do_saradc_close, "", ""),
+	U_BOOT_CMD_MKENT(getval, 1, 0, do_saradc_getval_12bit, "", ""),
+	U_BOOT_CMD_MKENT(get_in_range, 3, 0, do_saradc_get_in_range_12bit, "", ""),
+};
+
+static int do_saradc_12bit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cmd_tbl_t *c;
+	/* Strip off leading 'bmp' command argument */
+	argc--;
+	argv++;
+	c = find_cmd_tbl(argv[0], &cmd_saradc_12bit_sub[0], ARRAY_SIZE(cmd_saradc_12bit_sub));
+	if (c) {
+		return	c->cmd(cmdtp, flag, argc, argv);
+	} else {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+}
+
+U_BOOT_CMD(
+	saradc_12bit,	8,	0,	do_saradc_12bit,
+	"saradc sub-system",
+	"saradc_12bit open <channel>		- open a SARADC channel\n"
+	"saradc_12bit close	- close the SARADC\n"
+	"saradc_12bit getval	- get the value in current channel\n"
+	"saradc_12bit get_in_range <min> <max>	- return 0 if current value in the range of current channel\n"
+);
 
diff -Naur u-boot-2a56c9f.orig/drivers/adc/saradc.c u-boot-2a56c9f/drivers/adc/saradc.c
--- u-boot-2a56c9f.orig/drivers/adc/saradc.c	2016-09-18 14:08:59.266190015 +0800
+++ u-boot-2a56c9f/drivers/adc/saradc.c	2016-09-18 14:13:23.182192199 +0800
@@ -23,12 +23,12 @@
 #include <common.h>
 #include <asm/arch/io.h>
 #include <asm/saradc.h>
+#include <asm/cpu_id.h>
 
 //#define ENABLE_DYNAMIC_POWER
 
-
 #define CONFIG_GXBB 1
-
+static int flag_12bit;
 
 #if defined(CONFIG_GXBB)
 
@@ -52,6 +52,7 @@
 #define P_SAR_ADC_DETECT_IDLE_SW	(volatile unsigned int *)0xc8100624
 #define P_SAR_ADC_DELTA_10	        (volatile unsigned int *)0xc8100628
 #define P_SAR_ADC_DELTA_11          (volatile unsigned int *)0xc810062c
+#define P_SAR_ADC_REG13				(volatile unsigned int *)0xc8100634
 
 #else
 #define GXBB_CLK_REG                (volatile unsigned int *)0xc883c3d8
@@ -66,7 +67,9 @@
 #define P_SAR_ADC_CHAN_10_SW		(volatile unsigned int *)0xc11086a0
 #define P_SAR_ADC_DETECT_IDLE_SW	(volatile unsigned int *)0xc11086a4
 #define P_SAR_ADC_DELTA_10	        (volatile unsigned int *)0xc11086a8
-#define P_SAR_ADC_DELTA_11          (volatile unsigned int *)0xc11086aC
+#define P_SAR_ADC_DELTA_11          (volatile unsigned int *)0xc11086ac
+#define P_SAR_ADC_REG13				(volatile unsigned int *)0xc11086b4
+
 #endif
 /*
 #define P_SAR_ADC_DELTA_11		    (volatile unsigned int *)0xc11086a8
@@ -87,6 +90,7 @@
 #define PP_SAR_ADC_DETECT_IDLE_SW	    P_SAR_ADC_DETECT_IDLE_SW
 #define PP_SAR_ADC_DELTA_10				P_SAR_ADC_DELTA_10
 #define PP_SAR_ADC_DELTA_11				P_SAR_ADC_DELTA_11
+#define PP_SAR_ADC_REG13				P_SAR_ADC_REG13
 
 
 static __inline__ void aml_set_reg32_bits(volatile unsigned int *_reg, const uint32_t _value, const uint32_t _start, const uint32_t _len)
@@ -120,8 +124,10 @@
 #define SARADC_STATE_SUSPEND 2
 
 #define FLAG_INITIALIZED (1<<28)
-#define FLAG_BUSY (1<<29)
-
+//#define FLAG_BUSY (1<<29)
+#define FLAG_BUSY_KERNEL    (1<<14) /* for kernel:SARADC_DELAY 14bit */
+#define FLAG_BUSY_KERNEL_BIT  14
+#define FLAG_BUSY_BL30      (1<<15) /* for bl30:SARADC_DELAY 15bit*/
 
 //static u8 g_chan_mux[AML_ADC_SARADC_CHAN_NUM] = {0,1,2,3,4,5,6,7};
 
@@ -132,8 +138,9 @@
 	//struct saradc_reg3 *reg3 = (struct saradc_reg3 *)&adc->regs->reg3;
 
 	if (on) {
-        aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,1,13,1);
-        aml_set_reg32_bits(PP_SAR_ADC_REG3,1,21,1);
+		aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,1,13,1);
+		aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,3,5,2);
+		aml_set_reg32_bits(PP_SAR_ADC_REG3,1,21,1);
 
 		udelay(5);
 
@@ -149,29 +156,68 @@
 			aml_set_reg32_bits(PP_SAR_ADC_REG3,0,30,1);
         #endif
 		aml_set_reg32_bits(PP_SAR_ADC_REG3,0,30,1);
-        aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,0,13,1); /* disable bandgap */
+		/*aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,0,13,1);*//* disable bandgap */
+		aml_set_reg32_bits(PP_SAR_ADC_DELTA_11,0,5,2);
 	}
 }
+static void saradc_internal_cal_12bit(void)
+{
+	int val[5]/*, nominal[5] = {0, 1024, 2048, 3072, 4096}*/;
+	int i;
+	int abs_val = 4096;
+	unsigned int abs_num = 0;
+	unsigned int abs_tmp = 0;
 
+	/* set CAL_CNTL: 3/4 VDD*/
+	aml_set_reg32_bits(PP_SAR_ADC_REG3,3,23,3);
 
+	for (i = 0; i < 64; i++) {
+		aml_set_reg32_bits(PP_SAR_ADC_REG13,i,8,6);
+		udelay(5);
+		val[0] = get_adc_sample_gxbb_12bit(7);
+		//if (val[0] < 3000) {
+			abs_tmp = abs(3000 - val[0]);
+			if (abs_tmp < abs_val) {
+				abs_val = abs_tmp;
+				abs_num = i;
+			}
+		//}
+	}
+	aml_set_reg32_bits(PP_SAR_ADC_REG13,abs_num,8,6);
+}
+//#define NOT_USE_SINA_DETECT 1
+//#define CLK_DIV 19
 
 void saradc_enable(void)
 {
-    set_reg(P_SAR_SAR_ADC_REG0, 0x84004040);
-    set_reg(PP_SAR_ADC_CHAN_LIST, 0);
-    /* REG2: all chanel set to 8-samples & median averaging mode */
-    set_reg(PP_SAR_ADC_AVG_CNTL, 0);
-
-    set_reg(PP_SAR_ADC_REG3, 0x9388000a);
-    aml_set_reg32_bits(PP_SAR_ADC_REG3, 0x14,10,5);
-
-    #if GXBB_ADC
-    aml_write_reg32(GXBB_CLK_REG, (0<<9) | (20 << 0));
-    #endif
-    set_reg(PP_SAR_ADC_DELAY, 0x10a000a);
-    set_reg(PP_SAR_ADC_AUX_SW, 0x3eb1a0c);
-    set_reg(PP_SAR_ADC_CHAN_10_SW, 0x8c000c);
-    set_reg(PP_SAR_ADC_DETECT_IDLE_SW, 0xc000c);
+	if (get_cpu_id().family_id <= MESON_CPU_MAJOR_ID_GXTVBB)
+		flag_12bit = 0;
+	else
+		flag_12bit = 1;
+
+	printf("get_cpu_id flag_12bit=%d\n",flag_12bit);
+	set_reg(P_SAR_SAR_ADC_REG0, 0x84004040);
+	set_reg(PP_SAR_ADC_CHAN_LIST, 0);
+	/* REG2: all chanel set to 8-samples & median averaging mode */
+	set_reg(PP_SAR_ADC_AVG_CNTL, 0);
+
+	set_reg(PP_SAR_ADC_REG3, 0x9388000a);
+	aml_set_reg32_bits(PP_SAR_ADC_REG3,0x14,10,5);
+
+	/*gxl change vdd
+	set_reg(PP_SAR_ADC_REG13, );
+	gxl change sampling mode */
+	if (flag_12bit)
+		aml_set_reg32_bits(PP_SAR_ADC_REG3,0x1,27,1);
+
+
+#if GXBB_ADC
+	aml_write_reg32(GXBB_CLK_REG, (0<<9) | (20 << 0));
+#endif
+	set_reg(PP_SAR_ADC_DELAY, 0x10a000a);
+	set_reg(PP_SAR_ADC_AUX_SW, 0x3eb1a0c);
+	set_reg(PP_SAR_ADC_CHAN_10_SW, 0x8c000c);
+	set_reg(PP_SAR_ADC_DETECT_IDLE_SW, 0xc000c);
 
 #if AML_ADC_SAMPLE_DEBUG
 	printf("ADCREG reg0 =%x\n",   get_reg(PP_SAR_ADC_REG0));
@@ -181,11 +227,16 @@
 	printf("ADCREG ch72 sw =%x\n",get_reg(PP_SAR_ADC_AUX_SW));
 	printf("ADCREG ch10 sw =%x\n",get_reg(PP_SAR_ADC_CHAN_10_SW));
 	printf("ADCREG detect&idle=%x\n",get_reg(PP_SAR_ADC_DETECT_IDLE_SW));
-    printf("ADCREG GXBB_CLK_REG=%x\n",get_reg(GXBB_CLK_REG));
+	printf("ADCREG GXBB_CLK_REG=%x\n",get_reg(GXBB_CLK_REG));
 #endif //AML_ADC_SAMPLE_DEBUG
 
+	saradc_power_control(1);
+	saradc_internal_cal_12bit();
+}
 
-    saradc_power_control(1);
+void adc_set_clock(int div)
+{
+	aml_write_reg32(GXBB_CLK_REG, (1<<8) | (div << 0));
 }
 
 
@@ -211,15 +262,16 @@
 }
 */
 
-int get_adc_sample_gxbb(int ch)
+/*use_10bit_num=1,10 bit
+  use_10bit_num=0,12 bit*/
+int get_adc_sample_gxbb_early(int ch, int use_10bit_num)
 {
 	int value, count, sum;
 	//unsigned long flags;
-
 	//int adc_state = SARADC_STATE_BUSY;
 
 	count = 0;
-	while (aml_read_reg32(PP_SAR_ADC_REG3) & FLAG_BUSY) {
+	while (aml_read_reg32(PP_SAR_ADC_DELAY) & FLAG_BUSY_BL30) {
 		udelay(100);
 		if (++count > 100) {
 			printf("bl30 busy error\n");
@@ -227,6 +279,8 @@
 			goto end1;
 		}
 	}
+
+	aml_set_reg32_bits(PP_SAR_ADC_DELAY,1,FLAG_BUSY_KERNEL_BIT,1);
 	aml_set_reg32_bits(PP_SAR_ADC_REG3,1,29,1);
 
     set_reg(PP_SAR_ADC_CHAN_LIST, ch);
@@ -254,7 +308,19 @@
 
         value = aml_read_reg32(PP_SAR_ADC_FIFO_RD);
 		if (((value>>12) & 0x07) == ch) {
-			sum += value & 0x3ff;
+			if (use_10bit_num) {
+				//printf("10bit val~\n");
+				if (flag_12bit) {
+					value &= 0xffc;
+					value >>= 2;
+				} else
+					value &= 0x3ff;
+			} else {
+				//printf("12bit val~\n");
+				value &= 0xfff;
+			}
+
+			sum += value;
 			count++;
 		}	else
 			printf("chanel error\n");
@@ -267,19 +333,34 @@
 	}
 	value = sum / count;
 	//printf("before cal: %d, count=%d\n", value, count);
-
-    //value = saradc_get_cal_value(adc, value);
+	//value = saradc_get_cal_value(adc, value);
 end:
-    aml_set_reg32_bits(PP_SAR_ADC_REG0,1,14,1);
-    aml_set_reg32_bits(PP_SAR_ADC_REG0,0,0,1);
+	aml_set_reg32_bits(PP_SAR_ADC_REG0,1,14,1);
+	aml_set_reg32_bits(PP_SAR_ADC_REG0,0,0,1);
 
 end1:
-    aml_set_reg32_bits(PP_SAR_ADC_REG3,0,29,1);
-    //adc_state = SARADC_STATE_IDLE;
-
+	aml_set_reg32_bits(PP_SAR_ADC_REG3,0,29,1);
+	//adc_state = SARADC_STATE_IDLE;
+	aml_set_reg32_bits(PP_SAR_ADC_DELAY,0,FLAG_BUSY_KERNEL_BIT,1);
 	return value;
 }
 
+int get_adc_sample_gxbb(int ch)
+{
+	int val;
+	val = get_adc_sample_gxbb_early(ch, 1);
+	return val;
+}
+
+int get_adc_sample_gxbb_12bit(int ch)
+{
+	int val;
+	val = get_adc_sample_gxbb_early(ch, 0);
+	return val;
+
+}
+
+
 int saradc_disable(void)
 {
 	saradc_power_control(0);
