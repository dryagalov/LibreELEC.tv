diff -Naur linux-7f42343.orig/drivers/amlogic/cec/hdmi_ao_cec.c linux-7f42343/drivers/amlogic/cec/hdmi_ao_cec.c
--- linux-7f42343.orig/drivers/amlogic/cec/hdmi_ao_cec.c	2016-07-25 07:48:44.048460149 +0800
+++ linux-7f42343/drivers/amlogic/cec/hdmi_ao_cec.c	2016-07-25 08:02:47.476476328 +0800
@@ -62,8 +62,7 @@
 #include <linux/earlysuspend.h>
 static struct early_suspend aocec_suspend_handler;
 #endif
-#include <linux/amlogic/cpu_version.h>
-#include <linux/amlogic/jtag.h>
+
 
 #define CEC_FRAME_DELAY		msecs_to_jiffies(400)
 #define CEC_DEV_NAME		"cec"
@@ -74,7 +73,6 @@
 #define CEC_EARLY_SUSPEND	(1 << 0)
 #define CEC_DEEP_SUSPEND	(1 << 1)
 
-
 /* global struct for tx and rx */
 struct ao_cec_dev {
 	unsigned long dev_type;
@@ -118,16 +116,16 @@
 static unsigned char rx_msg[MAX_MSG];
 static unsigned char rx_len;
 static unsigned int  new_msg;
-bool cec_msg_dbg_en = 0;
+bool cec_msg_dbg_en = 0;	// FIXME
 
 #define CEC_ERR(format, args...)				\
 	{if (cec_dev->dbg_dev)					\
-		dev_err(cec_dev->dbg_dev, format, ##args);	\
+        dev_err(cec_dev->dbg_dev, "%s(): " format, __func__, ##args);  \
 	}
 
 #define CEC_INFO(format, args...)				\
 	{if (cec_msg_dbg_en && cec_dev->dbg_dev)		\
-		dev_info(cec_dev->dbg_dev, format, ##args);	\
+        dev_info(cec_dev->dbg_dev, "%s(): " format, __func__, ##args); \
 	}
 
 static unsigned char msg_log_buf[128] = { 0 };
@@ -143,6 +141,75 @@
 		} \
 	} while (0)
 
+#define HR_DELAY(n)     (ktime_set(0, n * 1000 * 1000))
+__u16 cec_key_map[160] = {
+    KEY_ENTER, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
+    0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x10
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_0 , KEY_1, KEY_2, KEY_3,KEY_4, KEY_5, KEY_6, KEY_7,//0x20
+    KEY_8 , KEY_9, KEY_DOT, 0, 0, 0, 0, 0,
+    KEY_CHANNELUP , KEY_CHANNELDOWN, KEY_CHANNEL, 0, 0, 0, 0, 0,//0x30
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    
+    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
+    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
+    0 , 0, 0, KEY_PROGRAM, 0, 0, 0, 0,//0x50
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
+    0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
+    0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
+    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x80
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    0 , KEY_EXIT, 0, 0, 0, 0, KEY_PVR, 0,//0x90  //samsung vendor buttons return and channel_list
+    0 , 0, 0, 0, 0, 0, 0, 0,
+};
+
+struct hrtimer cec_key_timer;
+static int last_key_irq = -1;
+static int key_value = 1;
+enum hrtimer_restart cec_key_up(struct hrtimer *timer)
+{
+    if (key_value == 1){
+        input_event(cec_dev->cec_info.remote_cec_dev,
+            EV_KEY, cec_key_map[last_key_irq], 0);
+    }
+    input_sync(cec_dev->cec_info.remote_cec_dev);
+    CEC_INFO("last:%d up\n", cec_key_map[last_key_irq]);
+    key_value = 2;
+
+    return HRTIMER_NORESTART;
+}
+
+void cec_user_control_pressed_irq(unsigned char message_irq)
+{
+    if (message_irq < 160) {
+        CEC_INFO("Key pressed: %d\n", message_irq);
+        input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY,
+                cec_key_map[message_irq], key_value);
+        input_sync(cec_dev->cec_info.remote_cec_dev);
+        last_key_irq = message_irq;
+        hrtimer_start(&cec_key_timer, HR_DELAY(200), HRTIMER_MODE_REL);
+        CEC_INFO(":key map:%d\n", cec_key_map[message_irq]);
+    }
+}
+
+void cec_user_control_released_irq(void)
+{
+    /*
+     * key must be valid
+     */
+    if (last_key_irq != -1) {
+        CEC_INFO("Key released: %d\n",last_key_irq);
+        hrtimer_cancel(&cec_key_timer);
+        input_event(cec_dev->cec_info.remote_cec_dev,
+            EV_KEY, cec_key_map[last_key_irq], 0);
+        input_sync(cec_dev->cec_info.remote_cec_dev);
+        key_value = 1;
+    }
+}
+
 void cec_set_reg_bits(unsigned int addr, unsigned int value,
 	unsigned int offset, unsigned int len)
 {
@@ -207,16 +274,70 @@
 	aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
 }
 
-void cec_logicaddr_set(int logicaddr)
+void cec_logicaddr_clear(void)
 {
-	aocec_wr_reg(CEC_LOGICAL_ADDR0, 0);
+    int i;
+    for (i = 0; i < 5; i++) {
+        aocec_wr_reg((CEC_LOGICAL_ADDR0 + i), 0);
+        cec_dev->cec_info.log_addr[i] = 0;
+        udelay(100);
+    }
 	cec_hw_buf_clear();
-	aocec_wr_reg(CEC_LOGICAL_ADDR0, (logicaddr & 0xf));
+}
+
+void cec_logicaddr_setByMask(unsigned int mask)
+{
+    int i, j;
+    int reg = 0;
+    int primary = -1;
+    // ignore reserved device type
+    const int device_types[5] = {CEC_RECORDING_DEVICE, 
+                                 CEC_PLAYBACK_DEVICE, 
+                                 CEC_TUNER_DEVICE,
+                                 CEC_AUDIO_SYSTEM_DEVICE,
+                                 CEC_DISPLAY_DEVICE|CEC_UNREGISTERED 
+                                 };
+    mask &= 0xffff;
+
+    if (mask == 0) {
+        cec_logicaddr_clear();
+        return;
+    }
+
+    for (i = CEC_TV_ADDR; i <= CEC_UNREGISTERED_ADDR; i++) {
+        if (reg > 4) {
+            break;
+        }
+        if ((mask & 1<<i) == 1<<i) {
+            for (j = 0; j <= sizeof(device_types); j++) {
+                // Max. one of each type
+                if (1<<i & device_types[j]) {
+                    CEC_INFO("ADDING LA:0x%d reg:0x%d\n", i, 
+                            (CEC_LOGICAL_ADDR0 + reg));
+                    mask &= ~(mask & device_types[j]);
+                    cec_dev->cec_info.log_addr[reg] = i;
+                    cec_logicaddr_set(i, (CEC_LOGICAL_ADDR0 + reg));
+                    if (primary == -1);
+                        primary = i;
+                        cec_logicaddr_config(primary, 1);
+                    reg++;
+                    break;
+                }
+            }
+        }
+    }
+}
+
+void cec_logicaddr_set(int logicaddr, int logreg)
+{
+    aocec_wr_reg(logreg, 0);
+    cec_hw_buf_clear();
+    aocec_wr_reg(logreg, (logicaddr & 0xf));
 	udelay(100);
-	aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | (logicaddr & 0xf));
+    aocec_wr_reg(logreg, (0x1 << 4) | (logicaddr & 0xf));
 	if (cec_msg_dbg_en)
 		CEC_INFO("set logical addr:0x%x\n",
-			aocec_rd_reg(CEC_LOGICAL_ADDR0));
+            aocec_rd_reg(logreg));
 }
 
 static void cec_hw_reset(void)
@@ -231,7 +352,7 @@
 	/* Enable all AO_CEC interrupt sources */
 	cec_set_reg_bits(AO_CEC_INTR_MASKN, 0x6, 0, 3);
 
-	cec_logicaddr_set(cec_dev->cec_info.log_addr);
+    cec_logicaddr_set(cec_dev->cec_info.log_addr[0], CEC_LOGICAL_ADDR0);
 
 	/* Cec arbitration 3/5/7 bit time set. */
 	cec_arbit_bit_time_set(3, 0x118, 0);
@@ -298,6 +419,41 @@
 	return ret;
 }
 
+void cec_polling_online_dev(int log_addr, int *bool)
+{
+    unsigned int r;
+    unsigned char msg[1];
+    int retry = 5;
+
+    msg[0] = (log_addr<<4) | log_addr;
+    /* set broadcast address first */
+    cec_logicaddr_set(0xf, CEC_LOGICAL_ADDR0);
+    if (cec_msg_dbg_en == 1)
+        CEC_INFO("CEC_LOGICAL_ADDR0:0x%i\n",
+               aocec_rd_reg(CEC_LOGICAL_ADDR0));
+    while (retry) {
+        r = cec_ll_tx(msg, 1);
+        if (r == CEC_FAIL_BUSY) {
+            retry--;
+            CEC_INFO("try log addr %x busy, retry:%d\n",
+                   log_addr, retry);
+            /*
+             * try to reset CEC if tx busy is found
+             */
+            cec_hw_reset();
+        } else
+            break;
+    }
+
+    if (r == CEC_FAIL_NACK) {
+        *bool = 0;
+    } else if (r == CEC_FAIL_NONE) {
+        *bool = 1;
+    }
+    CEC_INFO("CEC: poll online logic device: 0x%x BOOL: %d\n",
+        log_addr, *bool);
+}
+
 /************************ cec arbitration cts code **************************/
 /* using the cec pin as fiq gpi to assist the bus arbitration */
 
@@ -311,20 +467,28 @@
 	unsigned int j = 20;
 	unsigned tx_stat;
 	static int cec_timeout_cnt = 1;
+	int flag = 0;
 
 	while (1) {
 		tx_stat = aocec_rd_reg(CEC_TX_MSG_STATUS);
 		if (tx_stat != TX_BUSY)
 			break;
 
-		if (!(j--)) {
-			CEC_INFO("wating busy timeout\n");
+		if (!flag && tx_stat == TX_BUSY) {
+            CEC_INFO("TX is busy. Sending TX_ABORT\n");
 			aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+			flag = 1;
+		}
+
+        if (!(j--)) {
+            CEC_INFO("TX is still busy. Sending TX_NO_OP\n");
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
 			cec_timeout_cnt++;
-			if (cec_timeout_cnt > 0x08)
+            if (cec_timeout_cnt > 0x08) {
 				cec_hw_reset();
 			break;
 		}
+        }
 		msleep(20);
 	}
 
@@ -413,7 +577,7 @@
 	cec_tx_result = 0;
 	ret = wait_for_completion_timeout(&cec_dev->tx_ok, timeout);
 	if (ret <= 0) {
-		/* timeout or interrupt */
+        /* timeout of interrupt */
 		ret = CEC_FAIL_OTHER;
 		CEC_INFO("tx timeout\n");
 	} else {
@@ -613,7 +777,7 @@
 
 void cec_give_version(unsigned int dest)
 {
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 	unsigned char msg[3];
 
 	if (0xf != dest) {
@@ -627,7 +791,7 @@
 void cec_report_physical_address_smp(void)
 {
 	unsigned char msg[5];
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 	unsigned char phy_addr_ab, phy_addr_cd;
 
 	phy_addr_ab = (cec_dev->phy_addr >> 8) & 0xff;
@@ -643,7 +807,7 @@
 
 void cec_device_vendor_id(void)
 {
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 	unsigned char msg[5];
 	unsigned int vendor_id;
 
@@ -659,7 +823,7 @@
 
 void cec_give_deck_status(unsigned int dest)
 {
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 	unsigned char msg[3];
 
 	msg[0] = ((index & 0xf) << 4) | dest;
@@ -671,7 +835,7 @@
 void cec_menu_status_smp(int dest, int status)
 {
 	unsigned char msg[3];
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 
 	msg[0] = ((index & 0xf) << 4) | dest;
 	msg[1] = CEC_OC_MENU_STATUS;
@@ -682,9 +846,31 @@
 	cec_ll_tx(msg, 3);
 }
 
+void cec_imageview_on_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_IMAGE_VIEW_ON;
+    cec_ll_tx(msg, 2);
+}
+
+void cec_get_menu_language_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_GET_MENU_LANGUAGE;
+
+    cec_ll_tx(msg, 2);
+}
+
+
 void cec_inactive_source(int dest)
 {
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 	unsigned char msg[4];
 	unsigned char phy_addr_ab, phy_addr_cd;
 
@@ -700,7 +886,7 @@
 
 void cec_set_osd_name(int dest)
 {
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 	unsigned char osd_len = strlen(cec_dev->cec_info.osd_name);
 	unsigned char msg[16];
 
@@ -716,7 +902,7 @@
 void cec_active_source_smp(void)
 {
 	unsigned char msg[4];
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 	unsigned char phy_addr_ab;
 	unsigned char phy_addr_cd;
 
@@ -747,7 +933,7 @@
 
 void cec_report_power_status(int dest, int status)
 {
-	unsigned char index = cec_dev->cec_info.log_addr;
+    unsigned char index = cec_dev->cec_info.log_addr[0];
 	unsigned char msg[3];
 
 	msg[0] = ((index & 0xf) << 4) | dest;
@@ -756,6 +942,142 @@
 	cec_ll_tx(msg, 3);
 }
 
+void cec_send_simplink_alive(void)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[4];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_VENDOR_COMMAND;
+    msg[2] = 0x2;
+    msg[3] = 0x5;
+
+    cec_ll_tx(msg, 4);
+}
+
+void cec_send_simplink_ack(void)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[4];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_VENDOR_COMMAND;
+    msg[2] = 0x5;
+    msg[3] = 0x1;
+
+    cec_ll_tx(msg, 4);
+}
+
+int cec_node_init(struct hdmitx_dev *hdmitx_device)
+{
+    unsigned char a, b, c, d;
+
+    int i, bool = 0;
+    int phy_addr_ok = 1;
+    const enum _cec_log_dev_addr_e player_dev[3] = {
+        CEC_RECORDING_DEVICE_1_ADDR,
+        CEC_RECORDING_DEVICE_2_ADDR,
+        CEC_RECORDING_DEVICE_3_ADDR,
+    };
+
+    unsigned long cec_phy_addr;
+
+    /* If no connect, return directly */
+    if ((hdmitx_device->cec_init_ready == 0) ||
+        (hdmitx_device->hpd_state == 0)) {
+        return -1;
+    }
+    a = hdmitx_device->hdmi_info.vsdb_phy_addr.a;
+    b = hdmitx_device->hdmi_info.vsdb_phy_addr.b;
+    c = hdmitx_device->hdmi_info.vsdb_phy_addr.c;
+    d = hdmitx_device->hdmi_info.vsdb_phy_addr.d;
+
+    /* Don't init if switched to libcec mode*/
+    if ((cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL)))
+        return -1;
+
+    if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+        return -1;
+
+    CEC_INFO("cec_node_init started\n");
+
+    cec_phy_addr = ((a << 12) | (b << 8) | (c << 4) | (d << 0));
+
+    for (i = 0; i < 3; i++) {
+        CEC_INFO("CEC: start poll dev\n");
+        cec_polling_online_dev(player_dev[i], &bool);
+        CEC_INFO("player_dev[%d]:0x%x\n", i, player_dev[i]);
+        if (bool == 0) {   /* 0 means that no any respond */
+    /* If VSDB is not valid, use last or default physical address. */
+            cec_logicaddr_set(player_dev[i], CEC_LOGICAL_ADDR0);
+            if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
+                phy_addr_ok = 0;
+                CEC_INFO("invalid cec PhyAddr\n");
+                if (cec_phyaddr_config(0, 0)) {
+                    CEC_INFO("use last physical address\n");
+                } else {
+                    cec_phyaddr_config(0x2000, 1);
+                    CEC_INFO("use Def Phy address\n");
+                }
+            } else
+                cec_phyaddr_config(cec_phy_addr, 1);
+
+                CEC_INFO("physical address:0x%x\n",
+                        cec_phyaddr_config(0, 0));
+
+                cec_dev->cec_info.power_status = TRANS_STANDBY_TO_ON;
+                cec_logicaddr_config(player_dev[i], 1);
+                cec_dev->cec_info.log_addr[0] = player_dev[i];
+                /* Set Physical address */
+                cec_dev->phy_addr = cec_phy_addr;
+
+                cec_dev->cec_info.cec_version = CEC_VERSION_14A;
+                cec_dev->cec_info.vendor_id = cec_dev->v_data.vendor_id;
+                strcpy(cec_dev->cec_info.osd_name,
+                       cec_dev->v_data.cec_osd_string);
+                cec_logicaddr_set(player_dev[i], CEC_LOGICAL_ADDR0);
+
+                CEC_INFO("Set logical address: %d\n",
+                    player_dev[i]);
+
+                cec_dev->cec_info.power_status = POWER_ON;
+                if (cec_dev->cec_info.menu_status == DEVICE_MENU_INACTIVE)
+                    break;
+                msleep(100);
+                if (phy_addr_ok) {
+                    cec_report_physical_address_smp();
+                    msleep(150);
+                }
+                cec_device_vendor_id();
+                cec_set_osd_name(0);
+
+                /* Disable switch TV on automatically */
+                if (!(hdmitx_device->cec_func_config &
+                     (1 << AUTO_POWER_ON_MASK))) {
+                    CEC_INFO("Auto TV switch on disabled\n");
+                    break;
+                }
+
+                cec_active_source_smp();
+                cec_imageview_on_smp();
+
+                cec_menu_status_smp(CEC_TV_ADDR, DEVICE_MENU_ACTIVE);
+
+                msleep(100);
+                cec_get_menu_language_smp();
+                cec_dev->cec_info.menu_status = DEVICE_MENU_ACTIVE;
+            break;
+        }
+    }
+    if (bool == 1) {
+        CEC_INFO("Can't get a valid logical address\n");
+        return -1;
+    } else {
+        CEC_INFO("cec node init: cec features ok !\n");
+        return 0;
+    }
+}
+
 static void cec_rx_process(void)
 {
 	int len = rx_len;
@@ -769,7 +1091,7 @@
 	memcpy(msg, rx_msg, len);
 	initiator = ((msg[0] >> 4) & 0xf);
 	follower  = msg[0] & 0xf;
-	if (follower != 0xf && follower != cec_dev->cec_info.log_addr) {
+    if (follower != 0xf && follower != cec_dev->cec_info.log_addr[0]) {
 		CEC_ERR("wrong rx message of bad follower:%x", follower);
 		return;
 	}
@@ -819,7 +1141,15 @@
 			cec_report_power_status(initiator, POWER_ON);
 		break;
 
+
+    case CEC_OC_USER_CONTROL_RELEASED:
+        cec_user_control_released_irq();
+        break;
+
 	case CEC_OC_USER_CONTROL_PRESSED:
+        if (len < 3)
+            break;
+        cec_user_control_pressed_irq(msg[2]);
 		/* wake up by key function */
 		if (cec_dev->cec_suspend == CEC_EARLY_SUSPEND) {
 			if (msg[2] == 0x40 || msg[2] == 0x6d)
@@ -827,15 +1157,89 @@
 		}
 		break;
 
+    case CEC_OC_PLAY:
+        if (len < 3)
+            break;
+        switch (msg[2]) {
+        case 0x24:
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_PLAYPAUSE, 1);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_PLAYPAUSE, 0);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            break;
+        case 0x25:
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_PLAYPAUSE, 1);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_PLAYPAUSE, 0);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            break;
+        default:
+            break;
+        }
+        break;
+
+    case CEC_OC_DECK_CONTROL:
+        if (len < 3)
+            break;
+        switch (msg[2]) {
+        case 0x3:
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_STOP, 1);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_STOP, 0);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            break;
+        default:
+            break;
+        }
+        break;
+
+    case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        if (len < 3)
+            break;
+        switch(msg[2]){
+            //samsung vendor keys
+            case 0x91:
+                input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_EXIT, 1);
+                input_sync(cec_dev->cec_info.remote_cec_dev);
+                input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_EXIT, 0);
+                input_sync(cec_dev->cec_info.remote_cec_dev);
+                break;
+            case 0x96:
+                input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_LIST, 1);
+                input_sync(cec_dev->cec_info.remote_cec_dev);
+                input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_LIST, 0);
+                input_sync(cec_dev->cec_info.remote_cec_dev);
+                break;
+            default:
+                break;
+        }
+        break;
 	case CEC_OC_MENU_REQUEST:
 		if (cec_dev->cec_suspend)
 			cec_menu_status_smp(initiator, DEVICE_MENU_INACTIVE);
 		else
 			cec_menu_status_smp(initiator, DEVICE_MENU_ACTIVE);
 		break;
+    case CEC_OC_VENDOR_COMMAND:
+        if (len < 3)
+            break;
+        if (msg[2] == 0x1) {
+            cec_report_power_status(initiator, cec_dev->cec_info.power_status);
+            cec_send_simplink_alive();
+        } else if (msg[2] == 0x4) {
+            cec_send_simplink_ack();
+        }
+        break;
+	case CEC_OC_DEVICE_VENDOR_ID:
+		break;
 
 	default:
-		CEC_ERR("unsupported command:%x\n", opcode);
 		break;
 	}
 	new_msg = 0;
@@ -844,17 +1248,24 @@
 static void cec_task(struct work_struct *work)
 {
 	struct delayed_work *dwork;
+    int ret;
 
 	dwork = &cec_dev->cec_work;
 	if (cec_dev &&
 	   !(cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL))) {
+        if (1 << cec_dev->cec_info.log_addr[0] & (1 << 0x0 | 1 << 0xF)) {
+            ret = cec_node_init(cec_dev->tx_dev);
+            if (ret < 0) {
+                return;
+            }
+        }
 		cec_rx_process();
 	}
 	if (!cec_late_check_rx_buffer())
 		queue_delayed_work(cec_dev->cec_thread, dwork, CEC_FRAME_DELAY);
 }
 
-static irqreturn_t cec_isr_handler(int irq, void *dev_instance)
+irqreturn_t cec_isr_handler(int irq, void *dev_instance)
 {
 	unsigned int intr_stat = 0;
 	struct delayed_work *dwork;
@@ -962,19 +1373,20 @@
 static ssize_t port_status_show(struct class *cla,
 	struct class_attribute *attr, char *buf)
 {
-	unsigned int tmp;
+    unsigned int tmp = 0;
 
 	if (cec_dev->dev_type == DEV_TYPE_TX) {
 		tmp = cec_dev->tx_dev->hpd_state;
 		return sprintf(buf, "%x\n", tmp);
+    }
+     else {
 #ifdef CONFIG_TVIN_HDMI
-	} else {
 		tmp = hdmirx_rd_top(TOP_HPD_PWR5V);
 		CEC_INFO("TOP_HPD_PWR5V:%x\n", tmp);
 		tmp >>= 20;
 		tmp &= 0xf;
-		return sprintf(buf, "%x\n", tmp);
 #endif
+        return sprintf(buf, "%x\n", tmp);
 	}
 }
 
@@ -1075,6 +1487,7 @@
 
 	if (copy_to_user(buf, rx_msg, rx_len))
 		return -EINVAL;
+    CEC_INFO("RX len: %d\n", rx_len);
 	return rx_len;
 }
 
@@ -1095,7 +1508,12 @@
 	ret = cec_ll_tx(tempbuf, size);
 	/* delay a byte for continue message send */
 	msleep(25);
-	return ret;
+    if (ret == CEC_FAIL_NACK) {
+        return -1;
+    }
+    else {
+        return size;
+    }
 }
 
 static void init_cec_port_info(struct hdmi_port_info *port,
@@ -1260,9 +1678,13 @@
 
 	case CEC_IOC_ADD_LOGICAL_ADDR:
 		tmp = arg & 0xf;
-		cec_logicaddr_set(tmp);
+        CEC_INFO("CEC LA ARG:%ld", arg);
+        cec_logicaddr_set(tmp, CEC_LOGICAL_ADDR0);
+        cec_dev->cec_info.log_addr[0] = tmp;
+        /* TODO set multiple LA's. Does not work yet
+         * cec_logicaddr_setByMask(tmp);
+        */
 		/* add by hal, to init some data structure */
-		cec_dev->cec_info.log_addr = tmp;
 		cec_dev->cec_info.power_status = POWER_ON;
 		cec_logicaddr_config(tmp, 1);
 
@@ -1276,7 +1698,7 @@
 		break;
 
 	case CEC_IOC_CLR_LOGICAL_ADDR:
-		/* TODO: clear global info */
+        cec_logicaddr_clear();
 		break;
 
 	case CEC_IOC_SET_DEV_TYPE:
@@ -1358,6 +1780,7 @@
 
 static int aml_cec_probe(struct platform_device *pdev)
 {
+    int i;
 	struct device *cdev;
 #ifdef CONFIG_OF
 	struct device_node *node = pdev->dev.of_node;
@@ -1369,17 +1792,9 @@
 	resource_size_t *base;
 #endif
 
-	/* hdmi cec is conflict with jtag ao.
-	 * if jtag select apao, don't probe hdmi cec
-	 */
-	if (is_meson_gxtvbb_cpu() && is_jtag_apao()) {
-		pr_err("aocec: conflict with jtag apao, stop to probe");
-		return -EFAULT;
-	}
-
 	cec_dev = kzalloc(sizeof(struct ao_cec_dev), GFP_KERNEL);
 	if (!cec_dev) {
-		pr_err("aocec: alloc memory failed\n");
+        CEC_ERR("alloc memory failed\n");
 		return -ENOMEM;
 	}
 	cec_dev->dev_type = DEV_TYPE_TX;
@@ -1421,6 +1836,8 @@
 		return -EFAULT;
 	}
 	INIT_DELAYED_WORK(&cec_dev->cec_work, cec_task);
+    hrtimer_init(&cec_key_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    cec_key_timer.function = cec_key_up;
 	cec_dev->cec_info.remote_cec_dev = input_allocate_device();
 	if (!cec_dev->cec_info.remote_cec_dev)
 		CEC_INFO("No enough memory\n");
@@ -1435,8 +1852,8 @@
 	cec_dev->cec_info.remote_cec_dev->id.product = 0x0cec;
 	cec_dev->cec_info.remote_cec_dev->id.version = 0x0001;
 
-	set_bit(KEY_POWER, cec_dev->cec_info.remote_cec_dev->keybit);
-
+    for (i = 0; i < 160; i++)
+        set_bit(cec_key_map[i], cec_dev->cec_info.remote_cec_dev->keybit);
 	if (input_register_device(cec_dev->cec_info.remote_cec_dev)) {
 		CEC_INFO("Failed to register device\n");
 		input_free_device(cec_dev->cec_info.remote_cec_dev);
@@ -1532,7 +1949,6 @@
 			CEC_INFO("not find rx_port_maps\n");
 	}
 #endif
-
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	aocec_suspend_handler.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
 	aocec_suspend_handler.suspend = aocec_early_suspend;
@@ -1543,6 +1959,7 @@
 	/* for init */
 	cec_pre_init();
 	queue_delayed_work(cec_dev->cec_thread, &cec_dev->cec_work, 0);
+    cec_dev->tx_dev->cec_init_ready = 1;
 	return 0;
 }
 
@@ -1550,6 +1967,7 @@
 {
 	CEC_INFO("cec uninit!\n");
 	free_irq(cec_dev->irq_cec, (void *)cec_dev);
+    cec_dev->tx_dev->cec_init_ready = 0;
 
 	if (cec_dev->cec_thread) {
 		cancel_delayed_work_sync(&cec_dev->cec_work);
